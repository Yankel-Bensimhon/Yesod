// =====================================
// PHASE 2 - CALENDRIER INTELLIGENT
// =====================================

import { prisma } from './prisma'

// Types pour le calendrier intelligent
export interface SmartCalendarEvent {
  id: string
  title: string
  description?: string
  type: 'client_meeting' | 'court_hearing' | 'follow_up_call' | 'deadline' | 'payment_due'
  startTime: Date
  endTime: Date
  location?: string
  isVirtual: boolean
  participants: CalendarParticipant[]
  caseId?: string
  clientId?: string
  priority: 'low' | 'medium' | 'high' | 'critical'
  reminders: ReminderConfig[]
  autoGenerated: boolean
  metadata: Record<string, any>
}

export interface CalendarParticipant {
  id: string
  name: string
  email: string
  role: 'lawyer' | 'client' | 'assistant' | 'external'
  status: 'pending' | 'accepted' | 'declined' | 'tentative'
}

export interface ReminderConfig {
  type: 'email' | 'sms' | 'push'
  minutesBefore: number
  customMessage?: string
}

export interface AvailabilitySlot {
  start: Date
  end: Date
  duration: number // minutes
  type: 'available' | 'busy' | 'tentative'
}

// =====================================
// MOTEUR DE CALENDRIER INTELLIGENT
// =====================================

export class SmartCalendar {
  
  // Génération automatique d'événements basés sur les dossiers
  static async generateAutomatedEvents(caseId: string): Promise<SmartCalendarEvent[]> {
    try {
      const caseData = await prisma.case.findUnique({
        where: { id: caseId },
        include: {
          client: true,
          actions: true
        }
      })

      if (!caseData) {
        throw new Error('Case not found')
      }

      const events: SmartCalendarEvent[] = []
      const now = new Date()

      // Événement de suivi automatique après 7 jours
      const followUpDate = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000)
      events.push({
        id: `follow_up_${caseId}_${Date.now()}`,
        title: `Suivi dossier ${caseData.client?.name || 'Client'}`,
        description: `Suivi automatique du dossier - Vérifier l'avancement et les paiements`,
        type: 'follow_up_call',
        startTime: followUpDate,
        endTime: new Date(followUpDate.getTime() + 30 * 60 * 1000), // 30 minutes
        location: 'Appel téléphonique',
        isVirtual: true,
        participants: [
          {
            id: 'lawyer_1',
            name: 'Yankel Bensimhon',
            email: 'y.bensimhon@cabinet.fr',
            role: 'lawyer',
            status: 'accepted'
          }
        ],
        caseId,
        clientId: caseData.client?.id,
        priority: 'medium',
        reminders: [
          { type: 'email', minutesBefore: 1440 }, // 24h avant
          { type: 'push', minutesBefore: 30 }     // 30min avant
        ],
        autoGenerated: true,
        metadata: {
          generatedBy: 'system',
          reason: 'automatic_follow_up',
          caseAmount: caseData.amount
        }
      })

      // Échéance de paiement si applicable
      if (caseData.dueDate) {
        const paymentDueDate = new Date(caseData.dueDate)
        if (paymentDueDate > now) {
          events.push({
            id: `payment_due_${caseId}_${Date.now()}`,
            title: `Échéance paiement - ${caseData.client?.name || 'Client'}`,
            description: `Échéance de paiement pour le montant de ${caseData.amount}€`,
            type: 'payment_due',
            startTime: paymentDueDate,
            endTime: new Date(paymentDueDate.getTime() + 15 * 60 * 1000), // 15 minutes
            location: 'Suivi administratif',
            isVirtual: false,
            participants: [
              {
                id: 'lawyer_1',
                name: 'Yankel Bensimhon',
                email: 'y.bensimhon@cabinet.fr',
                role: 'lawyer',
                status: 'accepted'
              }
            ],
            caseId,
            clientId: caseData.client?.id,
            priority: 'high',
            reminders: [
              { type: 'email', minutesBefore: 2880 }, // 48h avant
              { type: 'email', minutesBefore: 1440 }, // 24h avant
              { type: 'sms', minutesBefore: 60 }      // 1h avant
            ],
            autoGenerated: true,
            metadata: {
              generatedBy: 'system',
              reason: 'payment_deadline',
              amount: caseData.amount
            }
          })
        }
      }

      // RDV client suggéré pour nouveaux dossiers importants
      if (caseData.amount && caseData.amount > 10000) {
        const clientMeetingDate = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000) // 3 jours
        events.push({
          id: `client_meeting_${caseId}_${Date.now()}`,
          title: `RDV stratégique - ${caseData.client?.name || 'Client'}`,
          description: `Rendez-vous stratégique pour dossier important (${caseData.amount}€)`,
          type: 'client_meeting',
          startTime: clientMeetingDate,
          endTime: new Date(clientMeetingDate.getTime() + 60 * 60 * 1000), // 1 heure
          location: 'Cabinet - Bureau principal',
          isVirtual: false,
          participants: [
            {
              id: 'lawyer_1',
              name: 'Yankel Bensimhon',
              email: 'y.bensimhon@cabinet.fr',
              role: 'lawyer',
              status: 'accepted'
            }
          ],
          caseId,
          clientId: caseData.client?.id,
          priority: 'high',
          reminders: [
            { type: 'email', minutesBefore: 1440 },
            { type: 'sms', minutesBefore: 120 }
          ],
          autoGenerated: true,
          metadata: {
            generatedBy: 'system',
            reason: 'high_value_case',
            suggestedMeeting: true
          }
        })
      }

      console.log(`Generated ${events.length} automated events for case ${caseId}`)
      return events

    } catch (error) {
      console.error('Error generating automated events:', error)
      throw error
    }
  }

  // Suggestion de créneaux optimaux
  static async suggestOptimalSlots(
    duration: number, // minutes
    preferredTimeRange: { start: string, end: string }, // HH:MM format
    excludeDays: string[] = [], // ['sunday', 'saturday']
    lookAheadDays: number = 30
  ): Promise<AvailabilitySlot[]> {
    try {
      const suggestions: AvailabilitySlot[] = []
      const now = new Date()
      
      // Créneaux de disponibilité type cabinet d'avocat
      const workingHours = {
        start: preferredTimeRange.start || '09:00',
        end: preferredTimeRange.end || '18:00'
      }

      for (let day = 0; day < lookAheadDays; day++) {
        const currentDate = new Date(now.getTime() + day * 24 * 60 * 60 * 1000)
        const dayName = currentDate.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase()
        
        // Exclure weekends et jours spécifiés
        if (excludeDays.includes(dayName) || dayName === 'saturday' || dayName === 'sunday') {
          continue
        }

        // Créer les créneaux de la journée
        const [startHour, startMin] = workingHours.start.split(':').map(Number)
        const [endHour, endMin] = workingHours.end.split(':').map(Number)
        
        const dayStart = new Date(currentDate)
        dayStart.setHours(startHour, startMin, 0, 0)
        
        const dayEnd = new Date(currentDate)
        dayEnd.setHours(endHour, endMin, 0, 0)

        // Générer créneaux de la durée demandée
        let slotStart = new Date(dayStart)
        while (slotStart.getTime() + duration * 60 * 1000 <= dayEnd.getTime()) {
          const slotEnd = new Date(slotStart.getTime() + duration * 60 * 1000)
          
          // Vérifier disponibilité (simulation - en prod, vérifier contre vraie agenda)
          const isAvailable = await SmartCalendar.checkAvailability(slotStart, slotEnd)
          
          if (isAvailable) {
            suggestions.push({
              start: new Date(slotStart),
              end: new Date(slotEnd),
              duration,
              type: 'available'
            })
          }

          // Passer au créneau suivant (intervalle de 30 minutes)
          slotStart = new Date(slotStart.getTime() + 30 * 60 * 1000)
        }
      }

      // Trier par proximité et priorité
      return suggestions
        .sort((a, b) => a.start.getTime() - b.start.getTime())
        .slice(0, 20) // Limiter à 20 suggestions

    } catch (error) {
      console.error('Error suggesting optimal slots:', error)
      return []
    }
  }

  // Vérification de disponibilité
  static async checkAvailability(start: Date, end: Date): Promise<boolean> {
    // Simulation - en production, vérifier contre la vraie base
    // const existingEvents = await prisma.calendarEvent.findMany({
    //   where: {
    //     OR: [
    //       { startDate: { lte: start }, endDate: { gte: start } },
    //       { startDate: { lte: end }, endDate: { gte: end } },
    //       { startDate: { gte: start }, endDate: { lte: end } }
    //     ]
    //   }
    // })
    
    // return existingEvents.length === 0

    // Pour la démo, considérer aléatoirement certains créneaux occupés
    return Math.random() > 0.3 // 70% de chance d'être disponible
  }

  // Gestion des rappels intelligents
  static async scheduleSmartReminders(eventId: string, event: SmartCalendarEvent) {
    try {
      for (const reminder of event.reminders) {
        const reminderTime = new Date(event.startTime.getTime() - reminder.minutesBefore * 60 * 1000)
        
        // Programmer rappel (en production, utiliser queue/scheduler)
        console.log(`Scheduling ${reminder.type} reminder for event ${eventId} at ${reminderTime.toISOString()}`)
        
        // Contenu du rappel adapté au type d'événement
        let message = reminder.customMessage
        if (!message) {
          switch (event.type) {
            case 'client_meeting':
              message = `Rappel: RDV client "${event.title}" prévu ${event.startTime.toLocaleString('fr-FR')}`
              break
            case 'court_hearing':
              message = `IMPORTANT: Audience "${event.title}" prévue ${event.startTime.toLocaleString('fr-FR')}`
              break
            case 'payment_due':
              message = `Échéance: Paiement attendu pour "${event.title}"`
              break
            default:
              message = `Rappel: "${event.title}" prévu ${event.startTime.toLocaleString('fr-FR')}`
          }
        }

        // En production, enregistrer en base ou dans un scheduler
        // await prisma.scheduledReminder.create({
        //   data: {
        //     eventId,
        //     type: reminder.type,
        //     scheduledFor: reminderTime,
        //     message,
        //     status: 'scheduled'
        //   }
        // })
      }
    } catch (error) {
      console.error('Error scheduling reminders:', error)
    }
  }

  // Synchronisation avec calendriers externes
  static async syncWithExternalCalendars(
    calendarType: 'google' | 'outlook' | 'apple',
    events: SmartCalendarEvent[]
  ) {
    try {
      console.log(`Syncing ${events.length} events with ${calendarType} calendar`)
      
      // Simulation de synchronisation
      for (const event of events) {
        // Format adapté au calendrier externe
        const externalEvent = {
          summary: event.title,
          description: event.description,
          start: event.startTime.toISOString(),
          end: event.endTime.toISOString(),
          location: event.location,
          attendees: event.participants.map(p => ({ email: p.email, displayName: p.name }))
        }
        
        console.log(`Synced event: ${event.title} to ${calendarType}`)
        
        // En production, utiliser les APIs respectives:
        // - Google Calendar API
        // - Microsoft Graph API pour Outlook
        // - CalDAV pour Apple Calendar
      }
      
      return { success: true, synced: events.length }
    } catch (error) {
      console.error(`Error syncing with ${calendarType}:`, error)
      return { success: false, error: error instanceof Error ? error.message : String(error) }
    }
  }

  // Détection de conflits d'horaires
  static detectScheduleConflicts(events: SmartCalendarEvent[]): Array<{
    conflict: boolean
    events: SmartCalendarEvent[]
    reason: string
  }> {
    const conflicts: Array<{
      conflict: boolean
      events: SmartCalendarEvent[]
      reason: string
    }> = []

    for (let i = 0; i < events.length; i++) {
      for (let j = i + 1; j < events.length; j++) {
        const event1 = events[i]
        const event2 = events[j]

        // Vérifier chevauchement temporel
        if (
          (event1.startTime <= event2.startTime && event1.endTime > event2.startTime) ||
          (event2.startTime <= event1.startTime && event2.endTime > event1.startTime)
        ) {
          conflicts.push({
            conflict: true,
            events: [event1, event2],
            reason: 'Chevauchement horaire détecté'
          })
        }

        // Vérifier conflits de participants
        const commonParticipants = event1.participants.filter(p1 =>
          event2.participants.some(p2 => p2.email === p1.email)
        )

        if (commonParticipants.length > 0) {
          const timeDiff = Math.abs(event1.startTime.getTime() - event2.startTime.getTime())
          if (timeDiff < 30 * 60 * 1000) { // Moins de 30 minutes d'écart
            conflicts.push({
              conflict: true,
              events: [event1, event2],
              reason: `Participant(s) en conflit: ${commonParticipants.map(p => p.name).join(', ')}`
            })
          }
        }
      }
    }

    return conflicts
  }

  // Optimisation automatique du planning
  static async optimizeSchedule(events: SmartCalendarEvent[]): Promise<{
    optimizedEvents: SmartCalendarEvent[]
    improvements: string[]
  }> {
    const improvements: string[] = []
    const optimizedEvents = [...events]

    // 1. Regrouper les événements par client
    const eventsByClient = new Map<string, SmartCalendarEvent[]>()
    
    events.forEach(event => {
      if (event.clientId) {
        if (!eventsByClient.has(event.clientId)) {
          eventsByClient.set(event.clientId, [])
        }
        eventsByClient.get(event.clientId)!.push(event)
      }
    })

    // 2. Suggérer regroupements
    eventsByClient.forEach((clientEvents, clientId) => {
      if (clientEvents.length > 1) {
        const timeSpread = Math.max(...clientEvents.map(e => e.startTime.getTime())) - 
                          Math.min(...clientEvents.map(e => e.startTime.getTime()))
        
        if (timeSpread < 7 * 24 * 60 * 60 * 1000) { // Moins d'une semaine
          improvements.push(`Possibilité de regrouper ${clientEvents.length} événements client en une seule session`)
        }
      }
    })

    // 3. Identifier les créneaux trop courts ou trop longs
    optimizedEvents.forEach(event => {
      const duration = event.endTime.getTime() - event.startTime.getTime()
      const durationMinutes = duration / (1000 * 60)

      if (event.type === 'client_meeting' && durationMinutes < 30) {
        improvements.push(`RDV client "${event.title}" pourrait nécessiter plus de 30 minutes`)
      }
      
      if (event.type === 'follow_up_call' && durationMinutes > 15) {
        improvements.push(`Appel de suivi "${event.title}" pourrait être raccourci à 15 minutes`)
      }
    })

    return {
      optimizedEvents,
      improvements
    }
  }
}

// =====================================
// GESTIONNAIRE DE TÂCHES AUTOMATIQUES
// =====================================

export class TaskAutomationManager {
  
  // Création automatique de tâches basées sur les événements
  static async createAutomatedTasks(event: SmartCalendarEvent): Promise<Array<{
    id: string
    title: string
    description: string
    dueDate: Date
    priority: 'low' | 'medium' | 'high'
    assignee: string
  }>> {
    const tasks: Array<{
      id: string
      title: string
      description: string
      dueDate: Date
      priority: 'low' | 'medium' | 'high'
      assignee: string
    }> = []

    switch (event.type) {
      case 'client_meeting':
        // Tâche de préparation
        tasks.push({
          id: `prep_${event.id}`,
          title: `Préparer RDV ${event.title}`,
          description: 'Réviser dossier, préparer documents et questions',
          dueDate: new Date(event.startTime.getTime() - 24 * 60 * 60 * 1000),
          priority: 'medium',
          assignee: 'lawyer'
        })
        
        // Tâche de suivi
        tasks.push({
          id: `followup_${event.id}`,
          title: `Compte-rendu RDV ${event.title}`,
          description: 'Rédiger CR, mettre à jour dossier, programmer actions',
          dueDate: new Date(event.endTime.getTime() + 2 * 60 * 60 * 1000),
          priority: 'high',
          assignee: 'lawyer'
        })
        break

      case 'court_hearing':
        // Préparation judiciaire
        tasks.push({
          id: `court_prep_${event.id}`,
          title: `Préparation audience ${event.title}`,
          description: 'Finaliser conclusions, vérifier pièces, répéter plaidoirie',
          dueDate: new Date(event.startTime.getTime() - 48 * 60 * 60 * 1000),
          priority: 'high',
          assignee: 'lawyer'
        })
        break

      case 'payment_due':
        // Relance automatique
        tasks.push({
          id: `payment_reminder_${event.id}`,
          title: `Relance paiement ${event.title}`,
          description: 'Vérifier paiement, envoyer relance si nécessaire',
          dueDate: new Date(event.startTime.getTime() + 24 * 60 * 60 * 1000),
          priority: 'medium',
          assignee: 'assistant'
        })
        break
    }

    console.log(`Created ${tasks.length} automated tasks for event ${event.id}`)
    return tasks
  }
}

// Export principal
export default SmartCalendar
